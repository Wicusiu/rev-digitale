/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * RevolutionDigitale
 * RevolutionDigitale
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    id: string;
    /**
     * time to live in seconds (2 weeks by default)
     * @type {number}
     * @memberof AccessToken
     */
    ttl?: number;
    /**
     * Array of scopes granted to this access token.
     * @type {Array&lt;string&gt;}
     * @memberof AccessToken
     */
    scopes?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof AccessToken
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    userId?: number;
}

/**
 * 
 * @export
 * @interface Brique
 */
export interface Brique {
    /**
     * 
     * @type {string}
     * @memberof Brique
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Brique
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Brique
     */
    logo: string;
    /**
     * 
     * @type {Date}
     * @memberof Brique
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Brique
     */
    modifiedDate: Date;
    /**
     * 
     * @type {number}
     * @memberof Brique
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Brique
     */
    moduleId?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    count?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    exists?: boolean;
}

/**
 * Information related to the outcome of the operation
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * The number of instances updated
     * @type {number}
     * @memberof InlineResponse2002
     */
    count?: number;
}

/**
 * 
 * @export
 * @interface Module
 */
export interface Module {
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    logo: string;
    /**
     * 
     * @type {number}
     * @memberof Module
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface NewBrique
 */
export interface NewBrique {
    /**
     * 
     * @type {string}
     * @memberof NewBrique
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewBrique
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof NewBrique
     */
    logo: string;
    /**
     * 
     * @type {Date}
     * @memberof NewBrique
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof NewBrique
     */
    modifiedDate: Date;
    /**
     * 
     * @type {number}
     * @memberof NewBrique
     */
    moduleId?: number;
}

/**
 * 
 * @export
 * @interface NewModule
 */
export interface NewModule {
    /**
     * 
     * @type {string}
     * @memberof NewModule
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NewModule
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof NewModule
     */
    logo: string;
}

/**
 * 
 * @export
 * @interface NewSession
 */
export interface NewSession {
    /**
     * 
     * @type {string}
     * @memberof NewSession
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewSession
     */
    description: string;
    /**
     * 
     * @type {Date}
     * @memberof NewSession
     */
    date: Date;
    /**
     * 
     * @type {string}
     * @memberof NewSession
     */
    location: string;
    /**
     * 
     * @type {string}
     * @memberof NewSession
     */
    moduleId: string;
    /**
     * 
     * @type {number}
     * @memberof NewSession
     */
    sessionId?: number;
}

/**
 * 
 * @export
 * @interface NewUser
 */
export interface NewUser {
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    realm?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewUser
     */
    emailVerified?: boolean;
}

/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    description: string;
    /**
     * 
     * @type {Date}
     * @memberof Session
     */
    date: Date;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    location: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    moduleId: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    sessionId?: number;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    realm?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    emailVerified?: boolean;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface XAny
 */
export interface XAny {
}


/**
 * BriqueApi - fetch parameter creator
 * @export
 */
export const BriqueApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/briques/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewBrique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCreate(data?: NewBrique, options: any = {}): FetchArgs {
            const localVarPath = `/briques`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewBrique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCreateChangeStreamGetBriquesChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/briques/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paramsStream !== undefined) {
                localVarQueryParameter['paramsStream'] = paramsStream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCreateChangeStreamPostBriquesChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/briques/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (paramsStream !== undefined) {
                localVarFormParams.set('paramsStream', paramsStream as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueDeleteById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling briqueDeleteById.');
            }
            const localVarPath = `/briques/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueExistsGetBriquesidExists(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling briqueExistsGetBriquesidExists.');
            }
            const localVarPath = `/briques/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueExistsHeadBriquesid(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling briqueExistsHeadBriquesid.');
            }
            const localVarPath = `/briques/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueFind(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/briques`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueFindById(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling briqueFindById.');
            }
            const localVarPath = `/briques/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueFindOne(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/briques/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briquePatchOrCreate(data?: Brique, options: any = {}): FetchArgs {
            const localVarPath = `/briques`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id brique id
         * @param {Brique} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briquePrototypePatchAttributes(id: string, data?: Brique, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling briquePrototypePatchAttributes.');
            }
            const localVarPath = `/briques/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceByIdPostBriquesidReplace(id: string, data?: Brique, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling briqueReplaceByIdPostBriquesidReplace.');
            }
            const localVarPath = `/briques/{id}/replace`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceByIdPutBriquesid(id: string, data?: Brique, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling briqueReplaceByIdPutBriquesid.');
            }
            const localVarPath = `/briques/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceOrCreatePostBriquesReplaceOrCreate(data?: Brique, options: any = {}): FetchArgs {
            const localVarPath = `/briques/replaceOrCreate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceOrCreatePutBriques(data?: Brique, options: any = {}): FetchArgs {
            const localVarPath = `/briques`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Brique} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueUpdateAll(where?: string, data?: Brique, options: any = {}): FetchArgs {
            const localVarPath = `/briques/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Brique} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueUpsertWithWhere(where?: string, data?: Brique, options: any = {}): FetchArgs {
            const localVarPath = `/briques/upsertWithWhere`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BriqueApi - functional programming interface
 * @export
 */
export const BriqueApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewBrique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCreate(data?: NewBrique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCreateChangeStreamGetBriquesChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueCreateChangeStreamGetBriquesChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCreateChangeStreamPostBriquesChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueCreateChangeStreamPostBriquesChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueDeleteById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueDeleteById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueExistsGetBriquesidExists(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueExistsGetBriquesidExists(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueExistsHeadBriquesid(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueExistsHeadBriquesid(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueFind(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Brique>> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueFind(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueFindById(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueFindById(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueFindOne(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueFindOne(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briquePatchOrCreate(data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briquePatchOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id brique id
         * @param {Brique} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briquePrototypePatchAttributes(id: string, data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briquePrototypePatchAttributes(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceByIdPostBriquesidReplace(id: string, data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueReplaceByIdPostBriquesidReplace(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceByIdPutBriquesid(id: string, data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueReplaceByIdPutBriquesid(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceOrCreatePostBriquesReplaceOrCreate(data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueReplaceOrCreatePostBriquesReplaceOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceOrCreatePutBriques(data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueReplaceOrCreatePutBriques(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Brique} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueUpdateAll(where?: string, data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueUpdateAll(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Brique} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueUpsertWithWhere(where?: string, data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = BriqueApiFetchParamCreator(configuration).briqueUpsertWithWhere(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BriqueApi - factory interface
 * @export
 */
export const BriqueApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCount(where?: string, options?: any) {
            return BriqueApiFp(configuration).briqueCount(where, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewBrique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCreate(data?: NewBrique, options?: any) {
            return BriqueApiFp(configuration).briqueCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCreateChangeStreamGetBriquesChangeStream(paramsStream?: string, options?: any) {
            return BriqueApiFp(configuration).briqueCreateChangeStreamGetBriquesChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueCreateChangeStreamPostBriquesChangeStream(paramsStream?: string, options?: any) {
            return BriqueApiFp(configuration).briqueCreateChangeStreamPostBriquesChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueDeleteById(id: string, options?: any) {
            return BriqueApiFp(configuration).briqueDeleteById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueExistsGetBriquesidExists(id: string, options?: any) {
            return BriqueApiFp(configuration).briqueExistsGetBriquesidExists(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueExistsHeadBriquesid(id: string, options?: any) {
            return BriqueApiFp(configuration).briqueExistsHeadBriquesid(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueFind(filter?: string, options?: any) {
            return BriqueApiFp(configuration).briqueFind(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueFindById(id: string, filter?: string, options?: any) {
            return BriqueApiFp(configuration).briqueFindById(id, filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueFindOne(filter?: string, options?: any) {
            return BriqueApiFp(configuration).briqueFindOne(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briquePatchOrCreate(data?: Brique, options?: any) {
            return BriqueApiFp(configuration).briquePatchOrCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id brique id
         * @param {Brique} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briquePrototypePatchAttributes(id: string, data?: Brique, options?: any) {
            return BriqueApiFp(configuration).briquePrototypePatchAttributes(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceByIdPostBriquesidReplace(id: string, data?: Brique, options?: any) {
            return BriqueApiFp(configuration).briqueReplaceByIdPostBriquesidReplace(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceByIdPutBriquesid(id: string, data?: Brique, options?: any) {
            return BriqueApiFp(configuration).briqueReplaceByIdPutBriquesid(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceOrCreatePostBriquesReplaceOrCreate(data?: Brique, options?: any) {
            return BriqueApiFp(configuration).briqueReplaceOrCreatePostBriquesReplaceOrCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brique} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueReplaceOrCreatePutBriques(data?: Brique, options?: any) {
            return BriqueApiFp(configuration).briqueReplaceOrCreatePutBriques(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Brique} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueUpdateAll(where?: string, data?: Brique, options?: any) {
            return BriqueApiFp(configuration).briqueUpdateAll(where, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Brique} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        briqueUpsertWithWhere(where?: string, data?: Brique, options?: any) {
            return BriqueApiFp(configuration).briqueUpsertWithWhere(where, data, options)(fetch, basePath);
        },
    };
};

/**
 * BriqueApi - object-oriented interface
 * @export
 * @class BriqueApi
 * @extends {BaseAPI}
 */
export class BriqueApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueCount(where?: string, options?: any) {
        return BriqueApiFp(this.configuration).briqueCount(where, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueCreate(data?: NewBrique, options?: any) {
        return BriqueApiFp(this.configuration).briqueCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a change stream.
     * @param {} [paramsStream] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueCreateChangeStreamGetBriquesChangeStream(paramsStream?: string, options?: any) {
        return BriqueApiFp(this.configuration).briqueCreateChangeStreamGetBriquesChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a change stream.
     * @param {} [paramsStream] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueCreateChangeStreamPostBriquesChangeStream(paramsStream?: string, options?: any) {
        return BriqueApiFp(this.configuration).briqueCreateChangeStreamPostBriquesChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueDeleteById(id: string, options?: any) {
        return BriqueApiFp(this.configuration).briqueDeleteById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueExistsGetBriquesidExists(id: string, options?: any) {
        return BriqueApiFp(this.configuration).briqueExistsGetBriquesidExists(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueExistsHeadBriquesid(id: string, options?: any) {
        return BriqueApiFp(this.configuration).briqueExistsHeadBriquesid(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueFind(filter?: string, options?: any) {
        return BriqueApiFp(this.configuration).briqueFind(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueFindById(id: string, filter?: string, options?: any) {
        return BriqueApiFp(this.configuration).briqueFindById(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueFindOne(filter?: string, options?: any) {
        return BriqueApiFp(this.configuration).briqueFindOne(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briquePatchOrCreate(data?: Brique, options?: any) {
        return BriqueApiFp(this.configuration).briquePatchOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param {} id brique id
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briquePrototypePatchAttributes(id: string, data?: Brique, options?: any) {
        return BriqueApiFp(this.configuration).briquePrototypePatchAttributes(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueReplaceByIdPostBriquesidReplace(id: string, data?: Brique, options?: any) {
        return BriqueApiFp(this.configuration).briqueReplaceByIdPostBriquesidReplace(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueReplaceByIdPutBriquesid(id: string, data?: Brique, options?: any) {
        return BriqueApiFp(this.configuration).briqueReplaceByIdPutBriquesid(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueReplaceOrCreatePostBriquesReplaceOrCreate(data?: Brique, options?: any) {
        return BriqueApiFp(this.configuration).briqueReplaceOrCreatePostBriquesReplaceOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueReplaceOrCreatePutBriques(data?: Brique, options?: any) {
        return BriqueApiFp(this.configuration).briqueReplaceOrCreatePutBriques(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueUpdateAll(where?: string, data?: Brique, options?: any) {
        return BriqueApiFp(this.configuration).briqueUpdateAll(where, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BriqueApi
     */
    public briqueUpsertWithWhere(where?: string, data?: Brique, options?: any) {
        return BriqueApiFp(this.configuration).briqueUpsertWithWhere(where, data, options)(this.fetch, this.basePath);
    }

}

/**
 * ModuleApi - fetch parameter creator
 * @export
 */
export const ModuleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewModule} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreate(data?: NewModule, options: any = {}): FetchArgs {
            const localVarPath = `/modules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewModule" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamGetModulesChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paramsStream !== undefined) {
                localVarQueryParameter['paramsStream'] = paramsStream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamPostModulesChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (paramsStream !== undefined) {
                localVarFormParams.set('paramsStream', paramsStream as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleDeleteById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moduleDeleteById.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsGetModulesidExists(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moduleExistsGetModulesidExists.');
            }
            const localVarPath = `/modules/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsHeadModulesid(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moduleExistsHeadModulesid.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFind(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindById(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moduleFindById.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindOne(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePatchOrCreate(data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cre une instance dans briqueId de ce modle.
         * @param {string} id module id
         * @param {Brique} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeCreateBriqueId(id: string, data?: Brique, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modulePrototypeCreateBriqueId.');
            }
            const localVarPath = `/modules/{id}/briqueId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Supprime briqueId de ce modle.
         * @param {string} id module id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeDestroyBriqueId(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modulePrototypeDestroyBriqueId.');
            }
            const localVarPath = `/modules/{id}/briqueId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extrait la relation hasOne briqueId.
         * @param {string} id module id
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeGetBriqueId(id: string, refresh?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modulePrototypeGetBriqueId.');
            }
            const localVarPath = `/modules/{id}/briqueId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id module id
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypePatchAttributes(id: string, data?: Module, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modulePrototypePatchAttributes.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mettez  jour briqueId de ce modle.
         * @param {string} id module id
         * @param {Brique} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeUpdateBriqueId(id: string, data?: Brique, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modulePrototypeUpdateBriqueId.');
            }
            const localVarPath = `/modules/{id}/briqueId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brique" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPostModulesidReplace(id: string, data?: Module, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moduleReplaceByIdPostModulesidReplace.');
            }
            const localVarPath = `/modules/{id}/replace`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPutModulesid(id: string, data?: Module, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moduleReplaceByIdPutModulesid.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePostModulesReplaceOrCreate(data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules/replaceOrCreate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePutModules(data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpdateAll(where?: string, data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpsertWithWhere(where?: string, data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules/upsertWithWhere`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModuleApi - functional programming interface
 * @export
 */
export const ModuleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewModule} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreate(data?: NewModule, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamGetModulesChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleCreateChangeStreamGetModulesChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamPostModulesChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleCreateChangeStreamPostModulesChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleDeleteById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleDeleteById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsGetModulesidExists(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleExistsGetModulesidExists(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsHeadModulesid(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleExistsHeadModulesid(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFind(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Module>> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleFind(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindById(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleFindById(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindOne(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleFindOne(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePatchOrCreate(data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePatchOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cre une instance dans briqueId de ce modle.
         * @param {string} id module id
         * @param {Brique} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeCreateBriqueId(id: string, data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypeCreateBriqueId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Supprime briqueId de ce modle.
         * @param {string} id module id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeDestroyBriqueId(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypeDestroyBriqueId(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Extrait la relation hasOne briqueId.
         * @param {string} id module id
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeGetBriqueId(id: string, refresh?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypeGetBriqueId(id, refresh, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id module id
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypePatchAttributes(id: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypePatchAttributes(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mettez  jour briqueId de ce modle.
         * @param {string} id module id
         * @param {Brique} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeUpdateBriqueId(id: string, data?: Brique, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brique> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypeUpdateBriqueId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPostModulesidReplace(id: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleReplaceByIdPostModulesidReplace(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPutModulesid(id: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleReplaceByIdPutModulesid(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePostModulesReplaceOrCreate(data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleReplaceOrCreatePostModulesReplaceOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePutModules(data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleReplaceOrCreatePutModules(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpdateAll(where?: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleUpdateAll(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpsertWithWhere(where?: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleUpsertWithWhere(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ModuleApi - factory interface
 * @export
 */
export const ModuleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCount(where?: string, options?: any) {
            return ModuleApiFp(configuration).moduleCount(where, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewModule} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreate(data?: NewModule, options?: any) {
            return ModuleApiFp(configuration).moduleCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamGetModulesChangeStream(paramsStream?: string, options?: any) {
            return ModuleApiFp(configuration).moduleCreateChangeStreamGetModulesChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamPostModulesChangeStream(paramsStream?: string, options?: any) {
            return ModuleApiFp(configuration).moduleCreateChangeStreamPostModulesChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleDeleteById(id: string, options?: any) {
            return ModuleApiFp(configuration).moduleDeleteById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsGetModulesidExists(id: string, options?: any) {
            return ModuleApiFp(configuration).moduleExistsGetModulesidExists(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsHeadModulesid(id: string, options?: any) {
            return ModuleApiFp(configuration).moduleExistsHeadModulesid(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFind(filter?: string, options?: any) {
            return ModuleApiFp(configuration).moduleFind(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindById(id: string, filter?: string, options?: any) {
            return ModuleApiFp(configuration).moduleFindById(id, filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindOne(filter?: string, options?: any) {
            return ModuleApiFp(configuration).moduleFindOne(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePatchOrCreate(data?: Module, options?: any) {
            return ModuleApiFp(configuration).modulePatchOrCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cre une instance dans briqueId de ce modle.
         * @param {string} id module id
         * @param {Brique} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeCreateBriqueId(id: string, data?: Brique, options?: any) {
            return ModuleApiFp(configuration).modulePrototypeCreateBriqueId(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Supprime briqueId de ce modle.
         * @param {string} id module id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeDestroyBriqueId(id: string, options?: any) {
            return ModuleApiFp(configuration).modulePrototypeDestroyBriqueId(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Extrait la relation hasOne briqueId.
         * @param {string} id module id
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeGetBriqueId(id: string, refresh?: boolean, options?: any) {
            return ModuleApiFp(configuration).modulePrototypeGetBriqueId(id, refresh, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id module id
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypePatchAttributes(id: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).modulePrototypePatchAttributes(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mettez  jour briqueId de ce modle.
         * @param {string} id module id
         * @param {Brique} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeUpdateBriqueId(id: string, data?: Brique, options?: any) {
            return ModuleApiFp(configuration).modulePrototypeUpdateBriqueId(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPostModulesidReplace(id: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleReplaceByIdPostModulesidReplace(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPutModulesid(id: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleReplaceByIdPutModulesid(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePostModulesReplaceOrCreate(data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleReplaceOrCreatePostModulesReplaceOrCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePutModules(data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleReplaceOrCreatePutModules(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpdateAll(where?: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleUpdateAll(where, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpsertWithWhere(where?: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleUpsertWithWhere(where, data, options)(fetch, basePath);
        },
    };
};

/**
 * ModuleApi - object-oriented interface
 * @export
 * @class ModuleApi
 * @extends {BaseAPI}
 */
export class ModuleApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleCount(where?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleCount(where, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleCreate(data?: NewModule, options?: any) {
        return ModuleApiFp(this.configuration).moduleCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a change stream.
     * @param {} [paramsStream] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleCreateChangeStreamGetModulesChangeStream(paramsStream?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleCreateChangeStreamGetModulesChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a change stream.
     * @param {} [paramsStream] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleCreateChangeStreamPostModulesChangeStream(paramsStream?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleCreateChangeStreamPostModulesChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleDeleteById(id: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleDeleteById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleExistsGetModulesidExists(id: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleExistsGetModulesidExists(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleExistsHeadModulesid(id: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleExistsHeadModulesid(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleFind(filter?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleFind(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleFindById(id: string, filter?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleFindById(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleFindOne(filter?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleFindOne(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePatchOrCreate(data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).modulePatchOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cre une instance dans briqueId de ce modle.
     * @param {} id module id
     * @param {} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypeCreateBriqueId(id: string, data?: Brique, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypeCreateBriqueId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Supprime briqueId de ce modle.
     * @param {} id module id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypeDestroyBriqueId(id: string, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypeDestroyBriqueId(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Extrait la relation hasOne briqueId.
     * @param {} id module id
     * @param {} [refresh] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypeGetBriqueId(id: string, refresh?: boolean, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypeGetBriqueId(id, refresh, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param {} id module id
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypePatchAttributes(id: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypePatchAttributes(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mettez  jour briqueId de ce modle.
     * @param {} id module id
     * @param {} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypeUpdateBriqueId(id: string, data?: Brique, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypeUpdateBriqueId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleReplaceByIdPostModulesidReplace(id: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleReplaceByIdPostModulesidReplace(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleReplaceByIdPutModulesid(id: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleReplaceByIdPutModulesid(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleReplaceOrCreatePostModulesReplaceOrCreate(data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleReplaceOrCreatePostModulesReplaceOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleReplaceOrCreatePutModules(data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleReplaceOrCreatePutModules(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleUpdateAll(where?: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleUpdateAll(where, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleUpsertWithWhere(where?: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleUpsertWithWhere(where, data, options)(this.fetch, this.basePath);
    }

}

/**
 * SessionApi - fetch parameter creator
 * @export
 */
export const SessionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewSession} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreate(data?: NewSession, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewSession" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamGetSessionsChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paramsStream !== undefined) {
                localVarQueryParameter['paramsStream'] = paramsStream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamPostSessionsChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (paramsStream !== undefined) {
                localVarFormParams.set('paramsStream', paramsStream as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionDeleteById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionDeleteById.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsGetSessionsidExists(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionExistsGetSessionsidExists.');
            }
            const localVarPath = `/sessions/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsHeadSessionsid(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionExistsHeadSessionsid.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFind(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindById(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionFindById.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindOne(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPatchOrCreate(data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cre une instance dans moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleId(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionPrototypeCreateModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cre une instance dans moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleIdModuleId(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionPrototypeCreateModuleIdModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Supprime moduleId de ce modle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleId(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionPrototypeDestroyModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Supprime moduleId de ce modle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleIdModuleId(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionPrototypeDestroyModuleIdModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleId(id: string, refresh?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionPrototypeGetModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleIdModuleId(id: string, refresh?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionPrototypeGetModuleIdModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id session id
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypePatchAttributes(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionPrototypePatchAttributes.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mettez  jour moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleId(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionPrototypeUpdateModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mettez  jour moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleIdModuleId(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionPrototypeUpdateModuleIdModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPostSessionsidReplace(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionReplaceByIdPostSessionsidReplace.');
            }
            const localVarPath = `/sessions/{id}/replace`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPutSessionsid(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sessionReplaceByIdPutSessionsid.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePostSessionsReplaceOrCreate(data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/replaceOrCreate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePutSessions(data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpdateAll(where?: string, data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpsertWithWhere(where?: string, data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/upsertWithWhere`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewSession} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreate(data?: NewSession, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamGetSessionsChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionCreateChangeStreamGetSessionsChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamPostSessionsChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionCreateChangeStreamPostSessionsChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionDeleteById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionDeleteById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsGetSessionsidExists(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionExistsGetSessionsidExists(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsHeadSessionsid(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionExistsHeadSessionsid(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFind(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Session>> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionFind(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindById(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionFindById(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindOne(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionFindOne(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPatchOrCreate(data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPatchOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cre une instance dans moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleId(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeCreateModuleId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cre une instance dans moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleIdModuleId(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeCreateModuleIdModuleId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Supprime moduleId de ce modle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleId(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeDestroyModuleId(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Supprime moduleId de ce modle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleIdModuleId(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeDestroyModuleIdModuleId(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleId(id: string, refresh?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeGetModuleId(id, refresh, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleIdModuleId(id: string, refresh?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeGetModuleIdModuleId(id, refresh, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id session id
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypePatchAttributes(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypePatchAttributes(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mettez  jour moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleId(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeUpdateModuleId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mettez  jour moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleIdModuleId(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeUpdateModuleIdModuleId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPostSessionsidReplace(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionReplaceByIdPostSessionsidReplace(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPutSessionsid(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionReplaceByIdPutSessionsid(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePostSessionsReplaceOrCreate(data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionReplaceOrCreatePostSessionsReplaceOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePutSessions(data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionReplaceOrCreatePutSessions(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpdateAll(where?: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionUpdateAll(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpsertWithWhere(where?: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionUpsertWithWhere(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCount(where?: string, options?: any) {
            return SessionApiFp(configuration).sessionCount(where, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewSession} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreate(data?: NewSession, options?: any) {
            return SessionApiFp(configuration).sessionCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamGetSessionsChangeStream(paramsStream?: string, options?: any) {
            return SessionApiFp(configuration).sessionCreateChangeStreamGetSessionsChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamPostSessionsChangeStream(paramsStream?: string, options?: any) {
            return SessionApiFp(configuration).sessionCreateChangeStreamPostSessionsChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionDeleteById(id: string, options?: any) {
            return SessionApiFp(configuration).sessionDeleteById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsGetSessionsidExists(id: string, options?: any) {
            return SessionApiFp(configuration).sessionExistsGetSessionsidExists(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsHeadSessionsid(id: string, options?: any) {
            return SessionApiFp(configuration).sessionExistsHeadSessionsid(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFind(filter?: string, options?: any) {
            return SessionApiFp(configuration).sessionFind(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindById(id: string, filter?: string, options?: any) {
            return SessionApiFp(configuration).sessionFindById(id, filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindOne(filter?: string, options?: any) {
            return SessionApiFp(configuration).sessionFindOne(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPatchOrCreate(data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPatchOrCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cre une instance dans moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleId(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeCreateModuleId(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cre une instance dans moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleIdModuleId(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeCreateModuleIdModuleId(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Supprime moduleId de ce modle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleId(id: string, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeDestroyModuleId(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Supprime moduleId de ce modle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleIdModuleId(id: string, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeDestroyModuleIdModuleId(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleId(id: string, refresh?: boolean, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeGetModuleId(id, refresh, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleIdModuleId(id: string, refresh?: boolean, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeGetModuleIdModuleId(id, refresh, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id session id
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypePatchAttributes(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypePatchAttributes(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mettez  jour moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleId(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeUpdateModuleId(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mettez  jour moduleId de ce modle.
         * @param {string} id session id
         * @param {Session} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleIdModuleId(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeUpdateModuleIdModuleId(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPostSessionsidReplace(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionReplaceByIdPostSessionsidReplace(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPutSessionsid(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionReplaceByIdPutSessionsid(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePostSessionsReplaceOrCreate(data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionReplaceOrCreatePostSessionsReplaceOrCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePutSessions(data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionReplaceOrCreatePutSessions(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpdateAll(where?: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionUpdateAll(where, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpsertWithWhere(where?: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionUpsertWithWhere(where, data, options)(fetch, basePath);
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionCount(where?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionCount(where, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionCreate(data?: NewSession, options?: any) {
        return SessionApiFp(this.configuration).sessionCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a change stream.
     * @param {} [paramsStream] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionCreateChangeStreamGetSessionsChangeStream(paramsStream?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionCreateChangeStreamGetSessionsChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a change stream.
     * @param {} [paramsStream] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionCreateChangeStreamPostSessionsChangeStream(paramsStream?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionCreateChangeStreamPostSessionsChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionDeleteById(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionDeleteById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionExistsGetSessionsidExists(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionExistsGetSessionsidExists(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionExistsHeadSessionsid(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionExistsHeadSessionsid(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionFind(filter?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionFind(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionFindById(id: string, filter?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionFindById(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionFindOne(filter?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionFindOne(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPatchOrCreate(data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPatchOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cre une instance dans moduleId de ce modle.
     * @param {} id session id
     * @param {} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeCreateModuleId(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeCreateModuleId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cre une instance dans moduleId de ce modle.
     * @param {} id session id
     * @param {} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeCreateModuleIdModuleId(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeCreateModuleIdModuleId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Supprime moduleId de ce modle.
     * @param {} id session id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeDestroyModuleId(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeDestroyModuleId(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Supprime moduleId de ce modle.
     * @param {} id session id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeDestroyModuleIdModuleId(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeDestroyModuleIdModuleId(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Extrait la relation hasOne moduleId.
     * @param {} id session id
     * @param {} [refresh] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeGetModuleId(id: string, refresh?: boolean, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeGetModuleId(id, refresh, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Extrait la relation hasOne moduleId.
     * @param {} id session id
     * @param {} [refresh] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeGetModuleIdModuleId(id: string, refresh?: boolean, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeGetModuleIdModuleId(id, refresh, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param {} id session id
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypePatchAttributes(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypePatchAttributes(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mettez  jour moduleId de ce modle.
     * @param {} id session id
     * @param {} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeUpdateModuleId(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeUpdateModuleId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mettez  jour moduleId de ce modle.
     * @param {} id session id
     * @param {} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeUpdateModuleIdModuleId(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeUpdateModuleIdModuleId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionReplaceByIdPostSessionsidReplace(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionReplaceByIdPostSessionsidReplace(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionReplaceByIdPutSessionsid(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionReplaceByIdPutSessionsid(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionReplaceOrCreatePostSessionsReplaceOrCreate(data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionReplaceOrCreatePostSessionsReplaceOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionReplaceOrCreatePutSessions(data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionReplaceOrCreatePutSessions(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionUpdateAll(where?: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionUpdateAll(where, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionUpsertWithWhere(where?: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionUpsertWithWhere(where, data, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param {string} oldPassword 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePassword(oldPassword: string, newPassword: string, options: any = {}): FetchArgs {
            // verify required parameter 'oldPassword' is not null or undefined
            if (oldPassword === null || oldPassword === undefined) {
                throw new RequiredError('oldPassword','Required parameter oldPassword was null or undefined when calling userChangePassword.');
            }
            // verify required parameter 'newPassword' is not null or undefined
            if (newPassword === null || newPassword === undefined) {
                throw new RequiredError('newPassword','Required parameter newPassword was null or undefined when calling userChangePassword.');
            }
            const localVarPath = `/Users/change-password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (oldPassword !== undefined) {
                localVarFormParams.set('oldPassword', oldPassword as any);
            }

            if (newPassword !== undefined) {
                localVarFormParams.set('newPassword', newPassword as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param {string} uid 
         * @param {string} token 
         * @param {string} [redirect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userConfirm(uid: string, token: string, redirect?: string, options: any = {}): FetchArgs {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling userConfirm.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling userConfirm.');
            }
            const localVarPath = `/Users/confirm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/Users/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewUser} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(data?: NewUser, options: any = {}): FetchArgs {
            const localVarPath = `/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateChangeStreamGetUsersChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/Users/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paramsStream !== undefined) {
                localVarQueryParameter['paramsStream'] = paramsStream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateChangeStreamPostUsersChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/Users/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (paramsStream !== undefined) {
                localVarFormParams.set('paramsStream', paramsStream as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userDeleteById.');
            }
            const localVarPath = `/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExistsGetUsersidExists(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userExistsGetUsersidExists.');
            }
            const localVarPath = `/Users/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExistsHeadUsersid(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userExistsHeadUsersid.');
            }
            const localVarPath = `/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFind(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFindById(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userFindById.');
            }
            const localVarPath = `/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFindOne(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/Users/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param {any} credentials 
         * @param {string} [include] Related objects to include in the response. See the description of return value for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(credentials: any, include?: string, options: any = {}): FetchArgs {
            // verify required parameter 'credentials' is not null or undefined
            if (credentials === null || credentials === undefined) {
                throw new RequiredError('credentials','Required parameter credentials was null or undefined when calling userLogin.');
            }
            const localVarPath = `/Users/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(credentials || {}) : (credentials || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout a user with access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(options: any = {}): FetchArgs {
            const localVarPath = `/Users/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPatchOrCreate(data?: User, options: any = {}): FetchArgs {
            const localVarPath = `/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Compte accessTokens de User.
         * @param {string} id User id
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeCountAccessTokens(id: string, where?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userPrototypeCountAccessTokens.');
            }
            const localVarPath = `/Users/{id}/accessTokens/count`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cre une instance dans accessTokens de ce modle.
         * @param {string} id User id
         * @param {AccessToken} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeCreateAccessTokens(id: string, data?: AccessToken, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userPrototypeCreateAccessTokens.');
            }
            const localVarPath = `/Users/{id}/accessTokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccessToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Supprime tous les accessTokens de ce modle.
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDeleteAccessTokens(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userPrototypeDeleteAccessTokens.');
            }
            const localVarPath = `/Users/{id}/accessTokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Supprimez un lment li par id pour accessTokens.
         * @param {string} id User id
         * @param {string} fk Cl externe pour accessTokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDestroyByIdAccessTokens(id: string, fk: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userPrototypeDestroyByIdAccessTokens.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk','Required parameter fk was null or undefined when calling userPrototypeDestroyByIdAccessTokens.');
            }
            const localVarPath = `/Users/{id}/accessTokens/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Recherchez un lment li par id pour accessTokens.
         * @param {string} id User id
         * @param {string} fk Cl externe pour accessTokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeFindByIdAccessTokens(id: string, fk: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userPrototypeFindByIdAccessTokens.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk','Required parameter fk was null or undefined when calling userPrototypeFindByIdAccessTokens.');
            }
            const localVarPath = `/Users/{id}/accessTokens/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Demandes accessTokens de User.
         * @param {string} id User id
         * @param {string} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetAccessTokens(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userPrototypeGetAccessTokens.');
            }
            const localVarPath = `/Users/{id}/accessTokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id User id
         * @param {User} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypePatchAttributes(id: string, data?: User, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userPrototypePatchAttributes.');
            }
            const localVarPath = `/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mettez  jour un lment li par id pour accessTokens.
         * @param {string} id User id
         * @param {string} fk Cl externe pour accessTokens
         * @param {AccessToken} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeUpdateByIdAccessTokens(id: string, fk: string, data?: AccessToken, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userPrototypeUpdateByIdAccessTokens.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk','Required parameter fk was null or undefined when calling userPrototypeUpdateByIdAccessTokens.');
            }
            const localVarPath = `/Users/{id}/accessTokens/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccessToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeVerify(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userPrototypeVerify.');
            }
            const localVarPath = `/Users/{id}/verify`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceByIdPostUsersidReplace(id: string, data?: User, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userReplaceByIdPostUsersidReplace.');
            }
            const localVarPath = `/Users/{id}/replace`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceByIdPutUsersid(id: string, data?: User, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userReplaceByIdPutUsersid.');
            }
            const localVarPath = `/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceOrCreatePostUsersReplaceOrCreate(data?: User, options: any = {}): FetchArgs {
            const localVarPath = `/Users/replaceOrCreate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceOrCreatePutUsers(data?: User, options: any = {}): FetchArgs {
            const localVarPath = `/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param {any} paramsPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetPassword(paramsPassword: any, options: any = {}): FetchArgs {
            // verify required parameter 'paramsPassword' is not null or undefined
            if (paramsPassword === null || paramsPassword === undefined) {
                throw new RequiredError('paramsPassword','Required parameter paramsPassword was null or undefined when calling userResetPassword.');
            }
            const localVarPath = `/Users/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(paramsPassword || {}) : (paramsPassword || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetPassword(newPassword: string, options: any = {}): FetchArgs {
            // verify required parameter 'newPassword' is not null or undefined
            if (newPassword === null || newPassword === undefined) {
                throw new RequiredError('newPassword','Required parameter newPassword was null or undefined when calling userSetPassword.');
            }
            const localVarPath = `/Users/reset-password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (newPassword !== undefined) {
                localVarFormParams.set('newPassword', newPassword as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {User} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateAll(where?: string, data?: User, options: any = {}): FetchArgs {
            const localVarPath = `/Users/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {User} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpsertWithWhere(where?: string, data?: User, options: any = {}): FetchArgs {
            const localVarPath = `/Users/upsertWithWhere`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param {string} oldPassword 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePassword(oldPassword: string, newPassword: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userChangePassword(oldPassword, newPassword, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param {string} uid 
         * @param {string} token 
         * @param {string} [redirect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userConfirm(uid: string, token: string, redirect?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userConfirm(uid, token, redirect, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewUser} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(data?: NewUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateChangeStreamGetUsersChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userCreateChangeStreamGetUsersChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateChangeStreamPostUsersChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userCreateChangeStreamPostUsersChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userDeleteById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExistsGetUsersidExists(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userExistsGetUsersidExists(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExistsHeadUsersid(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userExistsHeadUsersid(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFind(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userFind(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFindById(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userFindById(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFindOne(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userFindOne(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param {any} credentials 
         * @param {string} [include] Related objects to include in the response. See the description of return value for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(credentials: any, include?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userLogin(credentials, include, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logout a user with access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userLogout(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPatchOrCreate(data?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPatchOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Compte accessTokens de User.
         * @param {string} id User id
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeCountAccessTokens(id: string, where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeCountAccessTokens(id, where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cre une instance dans accessTokens de ce modle.
         * @param {string} id User id
         * @param {AccessToken} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeCreateAccessTokens(id: string, data?: AccessToken, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeCreateAccessTokens(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Supprime tous les accessTokens de ce modle.
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDeleteAccessTokens(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeDeleteAccessTokens(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Supprimez un lment li par id pour accessTokens.
         * @param {string} id User id
         * @param {string} fk Cl externe pour accessTokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDestroyByIdAccessTokens(id: string, fk: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeDestroyByIdAccessTokens(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Recherchez un lment li par id pour accessTokens.
         * @param {string} id User id
         * @param {string} fk Cl externe pour accessTokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeFindByIdAccessTokens(id: string, fk: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeFindByIdAccessTokens(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Demandes accessTokens de User.
         * @param {string} id User id
         * @param {string} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetAccessTokens(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccessToken>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeGetAccessTokens(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id User id
         * @param {User} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypePatchAttributes(id: string, data?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypePatchAttributes(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mettez  jour un lment li par id pour accessTokens.
         * @param {string} id User id
         * @param {string} fk Cl externe pour accessTokens
         * @param {AccessToken} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeUpdateByIdAccessTokens(id: string, fk: string, data?: AccessToken, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeUpdateByIdAccessTokens(id, fk, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeVerify(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeVerify(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceByIdPostUsersidReplace(id: string, data?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userReplaceByIdPostUsersidReplace(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceByIdPutUsersid(id: string, data?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userReplaceByIdPutUsersid(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceOrCreatePostUsersReplaceOrCreate(data?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userReplaceOrCreatePostUsersReplaceOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceOrCreatePutUsers(data?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userReplaceOrCreatePutUsers(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param {any} paramsPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetPassword(paramsPassword: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userResetPassword(paramsPassword, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetPassword(newPassword: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userSetPassword(newPassword, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {User} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateAll(where?: string, data?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userUpdateAll(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {User} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpsertWithWhere(where?: string, data?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userUpsertWithWhere(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param {string} oldPassword 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePassword(oldPassword: string, newPassword: string, options?: any) {
            return UserApiFp(configuration).userChangePassword(oldPassword, newPassword, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param {string} uid 
         * @param {string} token 
         * @param {string} [redirect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userConfirm(uid: string, token: string, redirect?: string, options?: any) {
            return UserApiFp(configuration).userConfirm(uid, token, redirect, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCount(where?: string, options?: any) {
            return UserApiFp(configuration).userCount(where, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewUser} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(data?: NewUser, options?: any) {
            return UserApiFp(configuration).userCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateChangeStreamGetUsersChangeStream(paramsStream?: string, options?: any) {
            return UserApiFp(configuration).userCreateChangeStreamGetUsersChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param {string} [paramsStream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateChangeStreamPostUsersChangeStream(paramsStream?: string, options?: any) {
            return UserApiFp(configuration).userCreateChangeStreamPostUsersChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteById(id: string, options?: any) {
            return UserApiFp(configuration).userDeleteById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExistsGetUsersidExists(id: string, options?: any) {
            return UserApiFp(configuration).userExistsGetUsersidExists(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExistsHeadUsersid(id: string, options?: any) {
            return UserApiFp(configuration).userExistsHeadUsersid(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFind(filter?: string, options?: any) {
            return UserApiFp(configuration).userFind(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFindById(id: string, filter?: string, options?: any) {
            return UserApiFp(configuration).userFindById(id, filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFindOne(filter?: string, options?: any) {
            return UserApiFp(configuration).userFindOne(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param {any} credentials 
         * @param {string} [include] Related objects to include in the response. See the description of return value for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(credentials: any, include?: string, options?: any) {
            return UserApiFp(configuration).userLogin(credentials, include, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout a user with access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(options?: any) {
            return UserApiFp(configuration).userLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPatchOrCreate(data?: User, options?: any) {
            return UserApiFp(configuration).userPatchOrCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Compte accessTokens de User.
         * @param {string} id User id
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeCountAccessTokens(id: string, where?: string, options?: any) {
            return UserApiFp(configuration).userPrototypeCountAccessTokens(id, where, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cre une instance dans accessTokens de ce modle.
         * @param {string} id User id
         * @param {AccessToken} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeCreateAccessTokens(id: string, data?: AccessToken, options?: any) {
            return UserApiFp(configuration).userPrototypeCreateAccessTokens(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Supprime tous les accessTokens de ce modle.
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDeleteAccessTokens(id: string, options?: any) {
            return UserApiFp(configuration).userPrototypeDeleteAccessTokens(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Supprimez un lment li par id pour accessTokens.
         * @param {string} id User id
         * @param {string} fk Cl externe pour accessTokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDestroyByIdAccessTokens(id: string, fk: string, options?: any) {
            return UserApiFp(configuration).userPrototypeDestroyByIdAccessTokens(id, fk, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Recherchez un lment li par id pour accessTokens.
         * @param {string} id User id
         * @param {string} fk Cl externe pour accessTokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeFindByIdAccessTokens(id: string, fk: string, options?: any) {
            return UserApiFp(configuration).userPrototypeFindByIdAccessTokens(id, fk, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Demandes accessTokens de User.
         * @param {string} id User id
         * @param {string} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetAccessTokens(id: string, filter?: string, options?: any) {
            return UserApiFp(configuration).userPrototypeGetAccessTokens(id, filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id User id
         * @param {User} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypePatchAttributes(id: string, data?: User, options?: any) {
            return UserApiFp(configuration).userPrototypePatchAttributes(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mettez  jour un lment li par id pour accessTokens.
         * @param {string} id User id
         * @param {string} fk Cl externe pour accessTokens
         * @param {AccessToken} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeUpdateByIdAccessTokens(id: string, fk: string, data?: AccessToken, options?: any) {
            return UserApiFp(configuration).userPrototypeUpdateByIdAccessTokens(id, fk, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeVerify(id: string, options?: any) {
            return UserApiFp(configuration).userPrototypeVerify(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceByIdPostUsersidReplace(id: string, data?: User, options?: any) {
            return UserApiFp(configuration).userReplaceByIdPostUsersidReplace(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceByIdPutUsersid(id: string, data?: User, options?: any) {
            return UserApiFp(configuration).userReplaceByIdPutUsersid(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceOrCreatePostUsersReplaceOrCreate(data?: User, options?: any) {
            return UserApiFp(configuration).userReplaceOrCreatePostUsersReplaceOrCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {User} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReplaceOrCreatePutUsers(data?: User, options?: any) {
            return UserApiFp(configuration).userReplaceOrCreatePutUsers(data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param {any} paramsPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetPassword(paramsPassword: any, options?: any) {
            return UserApiFp(configuration).userResetPassword(paramsPassword, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetPassword(newPassword: string, options?: any) {
            return UserApiFp(configuration).userSetPassword(newPassword, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {User} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateAll(where?: string, data?: User, options?: any) {
            return UserApiFp(configuration).userUpdateAll(where, data, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {User} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpsertWithWhere(where?: string, data?: User, options?: any) {
            return UserApiFp(configuration).userUpsertWithWhere(where, data, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Change a user's password.
     * @param {} oldPassword 
     * @param {} newPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userChangePassword(oldPassword: string, newPassword: string, options?: any) {
        return UserApiFp(this.configuration).userChangePassword(oldPassword, newPassword, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param {} uid 
     * @param {} token 
     * @param {} [redirect] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userConfirm(uid: string, token: string, redirect?: string, options?: any) {
        return UserApiFp(this.configuration).userConfirm(uid, token, redirect, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCount(where?: string, options?: any) {
        return UserApiFp(this.configuration).userCount(where, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreate(data?: NewUser, options?: any) {
        return UserApiFp(this.configuration).userCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a change stream.
     * @param {} [paramsStream] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateChangeStreamGetUsersChangeStream(paramsStream?: string, options?: any) {
        return UserApiFp(this.configuration).userCreateChangeStreamGetUsersChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a change stream.
     * @param {} [paramsStream] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateChangeStreamPostUsersChangeStream(paramsStream?: string, options?: any) {
        return UserApiFp(this.configuration).userCreateChangeStreamPostUsersChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteById(id: string, options?: any) {
        return UserApiFp(this.configuration).userDeleteById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userExistsGetUsersidExists(id: string, options?: any) {
        return UserApiFp(this.configuration).userExistsGetUsersidExists(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userExistsHeadUsersid(id: string, options?: any) {
        return UserApiFp(this.configuration).userExistsHeadUsersid(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userFind(filter?: string, options?: any) {
        return UserApiFp(this.configuration).userFind(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userFindById(id: string, filter?: string, options?: any) {
        return UserApiFp(this.configuration).userFindById(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userFindOne(filter?: string, options?: any) {
        return UserApiFp(this.configuration).userFindOne(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Login a user with username/email and password.
     * @param {} credentials 
     * @param {} [include] Related objects to include in the response. See the description of return value for more details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLogin(credentials: any, include?: string, options?: any) {
        return UserApiFp(this.configuration).userLogin(credentials, include, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Logout a user with access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLogout(options?: any) {
        return UserApiFp(this.configuration).userLogout(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPatchOrCreate(data?: User, options?: any) {
        return UserApiFp(this.configuration).userPatchOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Compte accessTokens de User.
     * @param {} id User id
     * @param {} [where] Criteria to match model instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeCountAccessTokens(id: string, where?: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeCountAccessTokens(id, where, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cre une instance dans accessTokens de ce modle.
     * @param {} id User id
     * @param {} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeCreateAccessTokens(id: string, data?: AccessToken, options?: any) {
        return UserApiFp(this.configuration).userPrototypeCreateAccessTokens(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Supprime tous les accessTokens de ce modle.
     * @param {} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeDeleteAccessTokens(id: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeDeleteAccessTokens(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Supprimez un lment li par id pour accessTokens.
     * @param {} id User id
     * @param {} fk Cl externe pour accessTokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeDestroyByIdAccessTokens(id: string, fk: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeDestroyByIdAccessTokens(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Recherchez un lment li par id pour accessTokens.
     * @param {} id User id
     * @param {} fk Cl externe pour accessTokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeFindByIdAccessTokens(id: string, fk: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeFindByIdAccessTokens(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Demandes accessTokens de User.
     * @param {} id User id
     * @param {} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeGetAccessTokens(id: string, filter?: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeGetAccessTokens(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param {} id User id
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypePatchAttributes(id: string, data?: User, options?: any) {
        return UserApiFp(this.configuration).userPrototypePatchAttributes(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mettez  jour un lment li par id pour accessTokens.
     * @param {} id User id
     * @param {} fk Cl externe pour accessTokens
     * @param {} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeUpdateByIdAccessTokens(id: string, fk: string, data?: AccessToken, options?: any) {
        return UserApiFp(this.configuration).userPrototypeUpdateByIdAccessTokens(id, fk, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param {} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeVerify(id: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeVerify(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userReplaceByIdPostUsersidReplace(id: string, data?: User, options?: any) {
        return UserApiFp(this.configuration).userReplaceByIdPostUsersidReplace(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userReplaceByIdPutUsersid(id: string, data?: User, options?: any) {
        return UserApiFp(this.configuration).userReplaceByIdPutUsersid(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userReplaceOrCreatePostUsersReplaceOrCreate(data?: User, options?: any) {
        return UserApiFp(this.configuration).userReplaceOrCreatePostUsersReplaceOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userReplaceOrCreatePutUsers(data?: User, options?: any) {
        return UserApiFp(this.configuration).userReplaceOrCreatePutUsers(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reset password for a user with email.
     * @param {} paramsPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userResetPassword(paramsPassword: any, options?: any) {
        return UserApiFp(this.configuration).userResetPassword(paramsPassword, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param {} newPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSetPassword(newPassword: string, options?: any) {
        return UserApiFp(this.configuration).userSetPassword(newPassword, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUpdateAll(where?: string, data?: User, options?: any) {
        return UserApiFp(this.configuration).userUpdateAll(where, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUpsertWithWhere(where?: string, data?: User, options?: any) {
        return UserApiFp(this.configuration).userUpsertWithWhere(where, data, options)(this.fetch, this.basePath);
    }

}

