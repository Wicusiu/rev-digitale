/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * RevolutionDigitale
 * RevolutionDigitale
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     *
     * @type {string}
     * @memberof AccessToken
     */
    id: string;
    /**
     * time to live in seconds (2 weeks by default)
     * @type {number}
     * @memberof AccessToken
     */
    ttl?: number;
    /**
     * Array of scopes granted to this access token.
     * @type {Array&lt;string&gt;}
     * @memberof AccessToken
     */
    scopes?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof AccessToken
     */
    created?: Date;
    /**
     *
     * @type {number}
     * @memberof AccessToken
     */
    userId?: number;
}

/**
 *
 * @export
 * @interface Brick
 */
export interface Brick {
    /**
     *
     * @type {string}
     * @memberof Brick
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Brick
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof Brick
     */
    logo: string;
    /**
     *
     * @type {Date}
     * @memberof Brick
     */
    createdDate?: Date;
    /**
     *
     * @type {Date}
     * @memberof Brick
     */
    modifiedDate: Date;
    /**
     *
     * @type {string}
     * @memberof Brick
     */
    id: string;
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {number}
     * @memberof InlineResponse200
     */
    count?: number;
}

/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     *
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    exists?: boolean;
}

/**
 * Information related to the outcome of the operation
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * The number of instances updated
     * @type {number}
     * @memberof InlineResponse2002
     */
    count?: number;
}

/**
 *
 * @export
 * @interface Module
 */
export interface Module {
    /**
     *
     * @type {string}
     * @memberof Module
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Module
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof Module
     */
    logo: string;
    /**
     *
     * @type {string}
     * @memberof Module
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Module
     */
    brickId?: string;
}

/**
 *
 * @export
 * @interface NewBrick
 */
export interface NewBrick {
    /**
     *
     * @type {string}
     * @memberof NewBrick
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof NewBrick
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof NewBrick
     */
    logo: string;
    /**
     *
     * @type {Date}
     * @memberof NewBrick
     */
    createdDate?: Date;
    /**
     *
     * @type {Date}
     * @memberof NewBrick
     */
    modifiedDate: Date;
}

/**
 *
 * @export
 * @interface NewModule
 */
export interface NewModule {
    /**
     *
     * @type {string}
     * @memberof NewModule
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof NewModule
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof NewModule
     */
    logo: string;
    /**
     *
     * @type {string}
     * @memberof NewModule
     */
    brickId?: string;
}

/**
 *
 * @export
 * @interface NewSession
 */
export interface NewSession {
    /**
     *
     * @type {string}
     * @memberof NewSession
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof NewSession
     */
    description: string;
    /**
     *
     * @type {Date}
     * @memberof NewSession
     */
    startDate: Date;
    /**
    *
    * @type {Date}
    * @memberof NewSession
    */
    endDate: Date;
    /**
     *
     * @type {string}
     * @memberof NewSession
     */
    location: string;
    /**
     *
     * @type {string}
     * @memberof NewSession
     */
    moduleId: string;

    /**
     *
     * @type {array}
     * @memberof NewSession
     */
    attendees?: Array<Attendee>;
}

export enum AttendeeParticipationStatus {
    Planned,
    Participated,
    Declined,
    Missed,
}

export class Attendee {
    /**
     *
     * @type {string}
     * @memberof Attendee
     */
    userId: string;
    /**
     *
     * @type {string}
     * @memberof Attendee
     */
    comment?: string;
    /**
     *
     * @type {string}
     * @memberof Attendee
     */
    rating?: number;
    /**
     *
     * @type {object}
     * @memberof Attendee
     */
    status: AttendeeParticipationStatus;
}

/**
 *
 * @export
 * @interface NewUser
 */
export interface NewUser {
    /**
     *
     * @type {string}
     * @memberof NewUser
     */
    realm?: string;
    /**
     *
     * @type {string}
     * @memberof NewUser
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof NewUser
     */
    lastName?: string;
    /**
     *
     * @type {string}
     * @memberof NewUser
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof NewUser
     */
    email: string;
    /**
     *
     * @type {boolean}
     * @memberof NewUser
     */
    emailVerified?: boolean;
}

/**
 *
 * @export
 * @interface Session
 */
export interface Session {
    /**
     *
     * @type {string}
     * @memberof Session
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Session
     */
    description: string;
    /**
     *
     * @type {Date}
     * @memberof Session
     */
    startDate: Date;
    /**
    *
    * @type {Date}
    * @memberof Session
    */
    endDate: Date;
    /**
     *
     * @type {string}
     * @memberof Session
     */
    location: string;
    /**
     *
     * @type {string}
     * @memberof Session
     */
    moduleId: string;
    /**
     *
     * @type {string}
     * @memberof Session
     */
    id: string;
    /**
     *
     * @type {array}
     * @memberof Session
     */
    attendees?: Array<Attendee>;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {string}
     * @memberof User
     */
    realm?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    emailVerified?: boolean;
    /**
     *
     * @type {string}
     * @memberof User
     */
    id: string;
}

/**
 *
 * @export
 * @interface JwtToken
 */
export interface JwtToken {
    /**
     *
     * @type {User}
     * @memberof JwtToken
     */
    user: User;
    /**
    *
    * @type {string}
    * @memberof UserCredentials
    */
    token: string;
}

/**
 *
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {

    /**
     *
     * @type {string}
     * @memberof UserCredentials
     */
    email: string;

    /**
     *
     * @type {string}
     * @memberof UserCredentials
     */
    password: string;
}

/**
 *
 * @export
 * @interface AuthCredentials
 */
export interface AuthCredentials {

    /**
     *
     * @type {string}
     * @memberof AuthCredentials
     */
    code: string;

    /**
     *
     * @type {string}
     * @memberof AuthCredentials
     */
    redirectURI: string;
}

/**
 *
 * @export
 * @interface XAny
 */
export interface XAny {
}


export class Pathway {
    /**
     *
     * @type {string}
     * @memberof Pathway
     */
    userId: string;
    /**
     *
     * @type {Array}
     * @memberof Pathway
     */
    moduleIds?: string[];
}


export class NewPathway {
    /**
     *
     * @type {string}
     * @memberof NewPathway
     */
    userId: string;
    /**
     *
     * @type {Array}
     * @memberof NewPathway
     */
    moduleIds?: string[];
}

/**
 * PathwayApi - fetch parameter creator
 * @export
 */
export const PathwayApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/pathways/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewPathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCreate(data?: NewPathway, options: any = {}): FetchArgs {
            const localVarPath = `/pathways`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewPathway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCreateChangeStreamGetPathwaysChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/pathways/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paramsStream !== undefined) {
                localVarQueryParameter['paramsStream'] = paramsStream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCreateChangeStreamPostPathwaysChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/pathways/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (paramsStream !== undefined) {
                localVarFormParams.set('paramsStream', paramsStream as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayDeleteById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling pathwayDeleteById.');
            }
            const localVarPath = `/pathways/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayExistsGetPathwaysidExists(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling pathwayExistsGetPathwaysidExists.');
            }
            const localVarPath = `/pathways/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayExistsHeadPathwaysid(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling pathwayExistsHeadPathwaysid.');
            }
            const localVarPath = `/pathways/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayFind(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/pathways`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayFindById(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling pathwayFindById.');
            }
            const localVarPath = `/pathways/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayFindOne(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/pathways/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayPatchOrCreate(data?: Pathway, options: any = {}): FetchArgs {
            const localVarPath = `/pathways`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pathway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id pathway id
         * @param {Pathway} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayPrototypePatchAttributes(id: string, data?: Pathway, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling pathwayPrototypePatchAttributes.');
            }
            const localVarPath = `/pathways/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pathway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceByIdPostPathwaysidReplace(id: string, data?: Pathway, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling pathwayReplaceByIdPostPathwaysidReplace.');
            }
            const localVarPath = `/pathways/{id}/replace`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pathway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceByIdPutPathwaysid(id: string, data?: Pathway, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling pathwayReplaceByIdPutPathwaysid.');
            }
            const localVarPath = `/pathways/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pathway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceOrCreatePostPathwaysReplaceOrCreate(data?: Pathway, options: any = {}): FetchArgs {
            const localVarPath = `/pathways/replaceOrCreate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pathway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceOrCreatePutPathways(data?: Pathway, options: any = {}): FetchArgs {
            const localVarPath = `/pathways`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pathway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Pathway} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayUpdateAll(where?: string, data?: Pathway, options: any = {}): FetchArgs {
            const localVarPath = `/pathways/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pathway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Pathway} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayUpsertWithWhere(where?: string, data?: Pathway, options: any = {}): FetchArgs {
            const localVarPath = `/pathways/upsertWithWhere`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pathway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PathwayApi - functional programming interface
 * @export
 */
export const PathwayApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewPathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCreate(data?: NewPathway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCreateChangeStreamGetPathwaysChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayCreateChangeStreamGetPathwaysChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCreateChangeStreamPostPathwaysChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayCreateChangeStreamPostPathwaysChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayDeleteById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayDeleteById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayExistsGetPathwaysidExists(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayExistsGetPathwaysidExists(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayExistsHeadPathwaysid(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayExistsHeadPathwaysid(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayFind(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Pathway>> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayFind(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayFindById(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayFindById(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayFindOne(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayFindOne(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayPatchOrCreate(data?: Pathway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayPatchOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id pathway id
         * @param {Pathway} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayPrototypePatchAttributes(id: string, data?: Pathway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayPrototypePatchAttributes(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceByIdPostPathwaysidReplace(id: string, data?: Pathway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayReplaceByIdPostPathwaysidReplace(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceByIdPutPathwaysid(id: string, data?: Pathway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayReplaceByIdPutPathwaysid(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceOrCreatePostPathwaysReplaceOrCreate(data?: Pathway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayReplaceOrCreatePostPathwaysReplaceOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceOrCreatePutPathways(data?: Pathway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayReplaceOrCreatePutPathways(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Pathway} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayUpdateAll(where?: string, data?: Pathway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayUpdateAll(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Pathway} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayUpsertWithWhere(where?: string, data?: Pathway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pathway> {
            const localVarFetchArgs = PathwayApiFetchParamCreator(configuration).pathwayUpsertWithWhere(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PathwayApi - factory interface
 * @export
 */
export const PathwayApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCount(where?: string, options?: any) {
            return PathwayApiFp(configuration).pathwayCount(where, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewPathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCreate(data?: NewPathway, options?: any) {
            return PathwayApiFp(configuration).pathwayCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCreateChangeStreamGetPathwaysChangeStream(paramsStream?: string, options?: any) {
            return PathwayApiFp(configuration).pathwayCreateChangeStreamGetPathwaysChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayCreateChangeStreamPostPathwaysChangeStream(paramsStream?: string, options?: any) {
            return PathwayApiFp(configuration).pathwayCreateChangeStreamPostPathwaysChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayDeleteById(id: string, options?: any) {
            return PathwayApiFp(configuration).pathwayDeleteById(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayExistsGetPathwaysidExists(id: string, options?: any) {
            return PathwayApiFp(configuration).pathwayExistsGetPathwaysidExists(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayExistsHeadPathwaysid(id: string, options?: any) {
            return PathwayApiFp(configuration).pathwayExistsHeadPathwaysid(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayFind(filter?: string, options?: any) {
            return PathwayApiFp(configuration).pathwayFind(filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayFindById(id: string, filter?: string, options?: any) {
            return PathwayApiFp(configuration).pathwayFindById(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayFindOne(filter?: string, options?: any) {
            return PathwayApiFp(configuration).pathwayFindOne(filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayPatchOrCreate(data?: Pathway, options?: any) {
            return PathwayApiFp(configuration).pathwayPatchOrCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id pathway id
         * @param {Pathway} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayPrototypePatchAttributes(id: string, data?: Pathway, options?: any) {
            return PathwayApiFp(configuration).pathwayPrototypePatchAttributes(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceByIdPostPathwaysidReplace(id: string, data?: Pathway, options?: any) {
            return PathwayApiFp(configuration).pathwayReplaceByIdPostPathwaysidReplace(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceByIdPutPathwaysid(id: string, data?: Pathway, options?: any) {
            return PathwayApiFp(configuration).pathwayReplaceByIdPutPathwaysid(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceOrCreatePostPathwaysReplaceOrCreate(data?: Pathway, options?: any) {
            return PathwayApiFp(configuration).pathwayReplaceOrCreatePostPathwaysReplaceOrCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Pathway} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayReplaceOrCreatePutPathways(data?: Pathway, options?: any) {
            return PathwayApiFp(configuration).pathwayReplaceOrCreatePutPathways(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Pathway} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayUpdateAll(where?: string, data?: Pathway, options?: any) {
            return PathwayApiFp(configuration).pathwayUpdateAll(where, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Pathway} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathwayUpsertWithWhere(where?: string, data?: Pathway, options?: any) {
            return PathwayApiFp(configuration).pathwayUpsertWithWhere(where, data, options)(fetch, basePath);
        },
    };
};

/**
 * PathwayApi - object-oriented interface
 * @export
 * @class PathwayApi
 * @extends {BaseAPI}
 */
export class PathwayApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayCount(where?: string, options?: any) {
        return PathwayApiFp(this.configuration).pathwayCount(where, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayCreate(data?: NewPathway, options?: any) {
        return PathwayApiFp(this.configuration).pathwayCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a change stream.
     * @param {} [paramsStream]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayCreateChangeStreamGetPathwaysChangeStream(paramsStream?: string, options?: any) {
        return PathwayApiFp(this.configuration).pathwayCreateChangeStreamGetPathwaysChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a change stream.
     * @param {} [paramsStream]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayCreateChangeStreamPostPathwaysChangeStream(paramsStream?: string, options?: any) {
        return PathwayApiFp(this.configuration).pathwayCreateChangeStreamPostPathwaysChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayDeleteById(id: string, options?: any) {
        return PathwayApiFp(this.configuration).pathwayDeleteById(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayExistsGetPathwaysidExists(id: string, options?: any) {
        return PathwayApiFp(this.configuration).pathwayExistsGetPathwaysidExists(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayExistsHeadPathwaysid(id: string, options?: any) {
        return PathwayApiFp(this.configuration).pathwayExistsHeadPathwaysid(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayFind(filter?: string, options?: any) {
        return PathwayApiFp(this.configuration).pathwayFind(filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayFindById(id: string, filter?: string, options?: any) {
        return PathwayApiFp(this.configuration).pathwayFindById(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayFindOne(filter?: string, options?: any) {
        return PathwayApiFp(this.configuration).pathwayFindOne(filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayPatchOrCreate(data?: Pathway, options?: any) {
        return PathwayApiFp(this.configuration).pathwayPatchOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param {} id pathway id
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayPrototypePatchAttributes(id: string, data?: Pathway, options?: any) {
        return PathwayApiFp(this.configuration).pathwayPrototypePatchAttributes(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayReplaceByIdPostPathwaysidReplace(id: string, data?: Pathway, options?: any) {
        return PathwayApiFp(this.configuration).pathwayReplaceByIdPostPathwaysidReplace(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayReplaceByIdPutPathwaysid(id: string, data?: Pathway, options?: any) {
        return PathwayApiFp(this.configuration).pathwayReplaceByIdPutPathwaysid(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayReplaceOrCreatePostPathwaysReplaceOrCreate(data?: Pathway, options?: any) {
        return PathwayApiFp(this.configuration).pathwayReplaceOrCreatePostPathwaysReplaceOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayReplaceOrCreatePutPathways(data?: Pathway, options?: any) {
        return PathwayApiFp(this.configuration).pathwayReplaceOrCreatePutPathways(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayUpdateAll(where?: string, data?: Pathway, options?: any) {
        return PathwayApiFp(this.configuration).pathwayUpdateAll(where, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathwayApi
     */
    public pathwayUpsertWithWhere(where?: string, data?: Pathway, options?: any) {
        return PathwayApiFp(this.configuration).pathwayUpsertWithWhere(where, data, options)(this.fetch, this.basePath);
    }

}


/**
 * BrickApi - fetch parameter creator
 * @export
 */
export const BrickApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bricks/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewBrick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCreate(data?: NewBrick, options: any = {}): FetchArgs {
            const localVarPath = `/bricks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewBrick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCreateChangeStreamGetBricksChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bricks/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paramsStream !== undefined) {
                localVarQueryParameter['paramsStream'] = paramsStream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCreateChangeStreamPostBricksChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bricks/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (paramsStream !== undefined) {
                localVarFormParams.set('paramsStream', paramsStream as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickDeleteById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling brickDeleteById.');
            }
            const localVarPath = `/bricks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickExistsGetBricksidExists(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling brickExistsGetBricksidExists.');
            }
            const localVarPath = `/bricks/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickExistsHeadBricksid(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling brickExistsHeadBricksid.');
            }
            const localVarPath = `/bricks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickFind(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bricks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickFindById(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling brickFindById.');
            }
            const localVarPath = `/bricks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickFindOne(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bricks/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickPatchOrCreate(data?: Brick, options: any = {}): FetchArgs {
            const localVarPath = `/bricks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id brick id
         * @param {Brick} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickPrototypePatchAttributes(id: string, data?: Brick, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling brickPrototypePatchAttributes.');
            }
            const localVarPath = `/bricks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceByIdPostBricksidReplace(id: string, data?: Brick, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling brickReplaceByIdPostBricksidReplace.');
            }
            const localVarPath = `/bricks/{id}/replace`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceByIdPutBricksid(id: string, data?: Brick, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling brickReplaceByIdPutBricksid.');
            }
            const localVarPath = `/bricks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceOrCreatePostBricksReplaceOrCreate(data?: Brick, options: any = {}): FetchArgs {
            const localVarPath = `/bricks/replaceOrCreate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceOrCreatePutBricks(data?: Brick, options: any = {}): FetchArgs {
            const localVarPath = `/bricks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Brick} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickUpdateAll(where?: string, data?: Brick, options: any = {}): FetchArgs {
            const localVarPath = `/bricks/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Brick} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickUpsertWithWhere(where?: string, data?: Brick, options: any = {}): FetchArgs {
            const localVarPath = `/bricks/upsertWithWhere`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrickApi - functional programming interface
 * @export
 */
export const BrickApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewBrick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCreate(data?: NewBrick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCreateChangeStreamGetBricksChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickCreateChangeStreamGetBricksChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCreateChangeStreamPostBricksChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickCreateChangeStreamPostBricksChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickDeleteById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickDeleteById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickExistsGetBricksidExists(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickExistsGetBricksidExists(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickExistsHeadBricksid(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickExistsHeadBricksid(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickFind(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Brick>> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickFind(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickFindById(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickFindById(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickFindOne(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickFindOne(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickPatchOrCreate(data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickPatchOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id brick id
         * @param {Brick} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickPrototypePatchAttributes(id: string, data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickPrototypePatchAttributes(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceByIdPostBricksidReplace(id: string, data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickReplaceByIdPostBricksidReplace(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceByIdPutBricksid(id: string, data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickReplaceByIdPutBricksid(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceOrCreatePostBricksReplaceOrCreate(data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickReplaceOrCreatePostBricksReplaceOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceOrCreatePutBricks(data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickReplaceOrCreatePutBricks(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Brick} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickUpdateAll(where?: string, data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickUpdateAll(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Brick} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickUpsertWithWhere(where?: string, data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = BrickApiFetchParamCreator(configuration).brickUpsertWithWhere(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BrickApi - factory interface
 * @export
 */
export const BrickApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCount(where?: string, options?: any) {
            return BrickApiFp(configuration).brickCount(where, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewBrick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCreate(data?: NewBrick, options?: any) {
            return BrickApiFp(configuration).brickCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCreateChangeStreamGetBricksChangeStream(paramsStream?: string, options?: any) {
            return BrickApiFp(configuration).brickCreateChangeStreamGetBricksChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickCreateChangeStreamPostBricksChangeStream(paramsStream?: string, options?: any) {
            return BrickApiFp(configuration).brickCreateChangeStreamPostBricksChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickDeleteById(id: string, options?: any) {
            return BrickApiFp(configuration).brickDeleteById(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickExistsGetBricksidExists(id: string, options?: any) {
            return BrickApiFp(configuration).brickExistsGetBricksidExists(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickExistsHeadBricksid(id: string, options?: any) {
            return BrickApiFp(configuration).brickExistsHeadBricksid(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickFind(filter?: string, options?: any) {
            return BrickApiFp(configuration).brickFind(filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickFindById(id: string, filter?: string, options?: any) {
            return BrickApiFp(configuration).brickFindById(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickFindOne(filter?: string, options?: any) {
            return BrickApiFp(configuration).brickFindOne(filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickPatchOrCreate(data?: Brick, options?: any) {
            return BrickApiFp(configuration).brickPatchOrCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id brick id
         * @param {Brick} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickPrototypePatchAttributes(id: string, data?: Brick, options?: any) {
            return BrickApiFp(configuration).brickPrototypePatchAttributes(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceByIdPostBricksidReplace(id: string, data?: Brick, options?: any) {
            return BrickApiFp(configuration).brickReplaceByIdPostBricksidReplace(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceByIdPutBricksid(id: string, data?: Brick, options?: any) {
            return BrickApiFp(configuration).brickReplaceByIdPutBricksid(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceOrCreatePostBricksReplaceOrCreate(data?: Brick, options?: any) {
            return BrickApiFp(configuration).brickReplaceOrCreatePostBricksReplaceOrCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Brick} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickReplaceOrCreatePutBricks(data?: Brick, options?: any) {
            return BrickApiFp(configuration).brickReplaceOrCreatePutBricks(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Brick} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickUpdateAll(where?: string, data?: Brick, options?: any) {
            return BrickApiFp(configuration).brickUpdateAll(where, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Brick} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brickUpsertWithWhere(where?: string, data?: Brick, options?: any) {
            return BrickApiFp(configuration).brickUpsertWithWhere(where, data, options)(fetch, basePath);
        },
    };
};

/**
 * BrickApi - object-oriented interface
 * @export
 * @class BrickApi
 * @extends {BaseAPI}
 */
export class BrickApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickCount(where?: string, options?: any) {
        return BrickApiFp(this.configuration).brickCount(where, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickCreate(data?: NewBrick, options?: any) {
        return BrickApiFp(this.configuration).brickCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a change stream.
     * @param {} [paramsStream]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickCreateChangeStreamGetBricksChangeStream(paramsStream?: string, options?: any) {
        return BrickApiFp(this.configuration).brickCreateChangeStreamGetBricksChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a change stream.
     * @param {} [paramsStream]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickCreateChangeStreamPostBricksChangeStream(paramsStream?: string, options?: any) {
        return BrickApiFp(this.configuration).brickCreateChangeStreamPostBricksChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickDeleteById(id: string, options?: any) {
        return BrickApiFp(this.configuration).brickDeleteById(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickExistsGetBricksidExists(id: string, options?: any) {
        return BrickApiFp(this.configuration).brickExistsGetBricksidExists(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickExistsHeadBricksid(id: string, options?: any) {
        return BrickApiFp(this.configuration).brickExistsHeadBricksid(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickFind(filter?: string, options?: any) {
        return BrickApiFp(this.configuration).brickFind(filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickFindById(id: string, filter?: string, options?: any) {
        return BrickApiFp(this.configuration).brickFindById(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickFindOne(filter?: string, options?: any) {
        return BrickApiFp(this.configuration).brickFindOne(filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickPatchOrCreate(data?: Brick, options?: any) {
        return BrickApiFp(this.configuration).brickPatchOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param {} id brick id
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickPrototypePatchAttributes(id: string, data?: Brick, options?: any) {
        return BrickApiFp(this.configuration).brickPrototypePatchAttributes(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickReplaceByIdPostBricksidReplace(id: string, data?: Brick, options?: any) {
        return BrickApiFp(this.configuration).brickReplaceByIdPostBricksidReplace(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickReplaceByIdPutBricksid(id: string, data?: Brick, options?: any) {
        return BrickApiFp(this.configuration).brickReplaceByIdPutBricksid(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickReplaceOrCreatePostBricksReplaceOrCreate(data?: Brick, options?: any) {
        return BrickApiFp(this.configuration).brickReplaceOrCreatePostBricksReplaceOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickReplaceOrCreatePutBricks(data?: Brick, options?: any) {
        return BrickApiFp(this.configuration).brickReplaceOrCreatePutBricks(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickUpdateAll(where?: string, data?: Brick, options?: any) {
        return BrickApiFp(this.configuration).brickUpdateAll(where, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrickApi
     */
    public brickUpsertWithWhere(where?: string, data?: Brick, options?: any) {
        return BrickApiFp(this.configuration).brickUpsertWithWhere(where, data, options)(this.fetch, this.basePath);
    }

}

/**
 * ModuleApi - fetch parameter creator
 * @export
 */
export const ModuleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewModule} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreate(data?: NewModule, options: any = {}): FetchArgs {
            const localVarPath = `/modules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewModule" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamGetModulesChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paramsStream !== undefined) {
                localVarQueryParameter['paramsStream'] = paramsStream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamPostModulesChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (paramsStream !== undefined) {
                localVarFormParams.set('paramsStream', paramsStream as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleDeleteById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling moduleDeleteById.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsGetModulesidExists(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling moduleExistsGetModulesidExists.');
            }
            const localVarPath = `/modules/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsHeadModulesid(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling moduleExistsHeadModulesid.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFind(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindById(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling moduleFindById.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindOne(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePatchOrCreate(data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Crée une instance dans brickId de ce modèle.
         * @param {string} id module id
         * @param {Brick} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeCreateBrickId(id: string, data?: Brick, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling modulePrototypeCreateBrickId.');
            }
            const localVarPath = `/modules/{id}/brickId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Supprime brickId de ce modèle.
         * @param {string} id module id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeDestroyBrickId(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling modulePrototypeDestroyBrickId.');
            }
            const localVarPath = `/modules/{id}/brickId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Extrait la relation hasOne brickId.
         * @param {string} id module id
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeGetBrickId(id: string, refresh?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling modulePrototypeGetBrickId.');
            }
            const localVarPath = `/modules/{id}/brickId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id module id
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypePatchAttributes(id: string, data?: Module, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling modulePrototypePatchAttributes.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Mettez à jour brickId de ce modèle.
         * @param {string} id module id
         * @param {Brick} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeUpdateBrickId(id: string, data?: Brick, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling modulePrototypeUpdateBrickId.');
            }
            const localVarPath = `/modules/{id}/brickId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Brick" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPostModulesidReplace(id: string, data?: Module, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling moduleReplaceByIdPostModulesidReplace.');
            }
            const localVarPath = `/modules/{id}/replace`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPutModulesid(id: string, data?: Module, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling moduleReplaceByIdPutModulesid.');
            }
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePostModulesReplaceOrCreate(data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules/replaceOrCreate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePutModules(data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpdateAll(where?: string, data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpsertWithWhere(where?: string, data?: Module, options: any = {}): FetchArgs {
            const localVarPath = `/modules/upsertWithWhere`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Module" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by brick and filter from the data source.
         * @param {string} [id] Id of a brick
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleGetByBrick(id: string, filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/modules/byBrick/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));

            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModuleApi - functional programming interface
 * @export
 */
export const ModuleApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewModule} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreate(data?: NewModule, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamGetModulesChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleCreateChangeStreamGetModulesChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamPostModulesChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleCreateChangeStreamPostModulesChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleDeleteById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleDeleteById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsGetModulesidExists(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleExistsGetModulesidExists(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsHeadModulesid(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleExistsHeadModulesid(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFind(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Module>> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleFind(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by brick id and filter from the data source.
         * @param {string} [id] Id of a brick
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleGetByBrick(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Module>> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleGetByBrick(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindById(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleFindById(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindOne(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleFindOne(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePatchOrCreate(data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePatchOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Crée une instance dans brickId de ce modèle.
         * @param {string} id module id
         * @param {Brick} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeCreateBrickId(id: string, data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypeCreateBrickId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Supprime brickId de ce modèle.
         * @param {string} id module id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeDestroyBrickId(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypeDestroyBrickId(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Extrait la relation hasOne brickId.
         * @param {string} id module id
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeGetBrickId(id: string, refresh?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypeGetBrickId(id, refresh, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id module id
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypePatchAttributes(id: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypePatchAttributes(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Mettez à jour brickId de ce modèle.
         * @param {string} id module id
         * @param {Brick} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeUpdateBrickId(id: string, data?: Brick, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Brick> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).modulePrototypeUpdateBrickId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPostModulesidReplace(id: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleReplaceByIdPostModulesidReplace(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPutModulesid(id: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleReplaceByIdPutModulesid(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePostModulesReplaceOrCreate(data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleReplaceOrCreatePostModulesReplaceOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePutModules(data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleReplaceOrCreatePutModules(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpdateAll(where?: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleUpdateAll(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpsertWithWhere(where?: string, data?: Module, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Module> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).moduleUpsertWithWhere(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ModuleApi - factory interface
 * @export
 */
export const ModuleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCount(where?: string, options?: any) {
            return ModuleApiFp(configuration).moduleCount(where, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewModule} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreate(data?: NewModule, options?: any) {
            return ModuleApiFp(configuration).moduleCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamGetModulesChangeStream(paramsStream?: string, options?: any) {
            return ModuleApiFp(configuration).moduleCreateChangeStreamGetModulesChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreateChangeStreamPostModulesChangeStream(paramsStream?: string, options?: any) {
            return ModuleApiFp(configuration).moduleCreateChangeStreamPostModulesChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleDeleteById(id: string, options?: any) {
            return ModuleApiFp(configuration).moduleDeleteById(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsGetModulesidExists(id: string, options?: any) {
            return ModuleApiFp(configuration).moduleExistsGetModulesidExists(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleExistsHeadModulesid(id: string, options?: any) {
            return ModuleApiFp(configuration).moduleExistsHeadModulesid(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFind(filter?: string, options?: any) {
            return ModuleApiFp(configuration).moduleFind(filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by brick and filter from the data source.
         * @param {string} [id] Id of a brick
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleGetByBrick(id: string, filter?: string, options?: any) {
            return ModuleApiFp(configuration).moduleGetByBrick(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindById(id: string, filter?: string, options?: any) {
            return ModuleApiFp(configuration).moduleFindById(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleFindOne(filter?: string, options?: any) {
            return ModuleApiFp(configuration).moduleFindOne(filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePatchOrCreate(data?: Module, options?: any) {
            return ModuleApiFp(configuration).modulePatchOrCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Crée une instance dans brickId de ce modèle.
         * @param {string} id module id
         * @param {Brick} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeCreateBrickId(id: string, data?: Brick, options?: any) {
            return ModuleApiFp(configuration).modulePrototypeCreateBrickId(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Supprime brickId de ce modèle.
         * @param {string} id module id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeDestroyBrickId(id: string, options?: any) {
            return ModuleApiFp(configuration).modulePrototypeDestroyBrickId(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Extrait la relation hasOne brickId.
         * @param {string} id module id
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeGetBrickId(id: string, refresh?: boolean, options?: any) {
            return ModuleApiFp(configuration).modulePrototypeGetBrickId(id, refresh, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id module id
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypePatchAttributes(id: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).modulePrototypePatchAttributes(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Mettez à jour brickId de ce modèle.
         * @param {string} id module id
         * @param {Brick} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulePrototypeUpdateBrickId(id: string, data?: Brick, options?: any) {
            return ModuleApiFp(configuration).modulePrototypeUpdateBrickId(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPostModulesidReplace(id: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleReplaceByIdPostModulesidReplace(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceByIdPutModulesid(id: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleReplaceByIdPutModulesid(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePostModulesReplaceOrCreate(data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleReplaceOrCreatePostModulesReplaceOrCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Module} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleReplaceOrCreatePutModules(data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleReplaceOrCreatePutModules(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpdateAll(where?: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleUpdateAll(where, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Module} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpsertWithWhere(where?: string, data?: Module, options?: any) {
            return ModuleApiFp(configuration).moduleUpsertWithWhere(where, data, options)(fetch, basePath);
        },
    };
};

/**
 * ModuleApi - object-oriented interface
 * @export
 * @class ModuleApi
 * @extends {BaseAPI}
 */
export class ModuleApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleCount(where?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleCount(where, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleCreate(data?: NewModule, options?: any) {
        return ModuleApiFp(this.configuration).moduleCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a change stream.
     * @param {} [paramsStream]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleCreateChangeStreamGetModulesChangeStream(paramsStream?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleCreateChangeStreamGetModulesChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a change stream.
     * @param {} [paramsStream]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleCreateChangeStreamPostModulesChangeStream(paramsStream?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleCreateChangeStreamPostModulesChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleDeleteById(id: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleDeleteById(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleExistsGetModulesidExists(id: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleExistsGetModulesidExists(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleExistsHeadModulesid(id: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleExistsHeadModulesid(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleFind(filter?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleFind(filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleFindById(id: string, filter?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleFindById(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleFindOne(filter?: string, options?: any) {
        return ModuleApiFp(this.configuration).moduleFindOne(filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePatchOrCreate(data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).modulePatchOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Crée une instance dans brickId de ce modèle.
     * @param {} id module id
     * @param {} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypeCreateBrickId(id: string, data?: Brick, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypeCreateBrickId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Supprime brickId de ce modèle.
     * @param {} id module id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypeDestroyBrickId(id: string, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypeDestroyBrickId(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Extrait la relation hasOne brickId.
     * @param {} id module id
     * @param {} [refresh]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypeGetBrickId(id: string, refresh?: boolean, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypeGetBrickId(id, refresh, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param {} id module id
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypePatchAttributes(id: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypePatchAttributes(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Mettez à jour brickId de ce modèle.
     * @param {} id module id
     * @param {} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public modulePrototypeUpdateBrickId(id: string, data?: Brick, options?: any) {
        return ModuleApiFp(this.configuration).modulePrototypeUpdateBrickId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleReplaceByIdPostModulesidReplace(id: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleReplaceByIdPostModulesidReplace(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleReplaceByIdPutModulesid(id: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleReplaceByIdPutModulesid(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleReplaceOrCreatePostModulesReplaceOrCreate(data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleReplaceOrCreatePostModulesReplaceOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleReplaceOrCreatePutModules(data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleReplaceOrCreatePutModules(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleUpdateAll(where?: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleUpdateAll(where, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleUpsertWithWhere(where?: string, data?: Module, options?: any) {
        return ModuleApiFp(this.configuration).moduleUpsertWithWhere(where, data, options)(this.fetch, this.basePath);
    }

}

/**
 * SessionApi - fetch parameter creator
 * @export
 */
export const SessionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewSession} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreate(data?: NewSession, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewSession" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Register a user to a session and persist it into the data source.
         * @param {{ userId: string, sessionId: string }} [data] Registration data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionRegister(data?: { userId: string, sessionId: string }, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ userId: string, sessionId: string }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamGetSessionsChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paramsStream !== undefined) {
                localVarQueryParameter['paramsStream'] = paramsStream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamPostSessionsChangeStream(paramsStream?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/change-stream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (paramsStream !== undefined) {
                localVarFormParams.set('paramsStream', paramsStream as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionDeleteById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionDeleteById.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsGetSessionsidExists(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionExistsGetSessionsidExists.');
            }
            const localVarPath = `/sessions/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsHeadSessionsid(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionExistsHeadSessionsid.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFind(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;

            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [moduleId] Id of a Module
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionGetByModule(moduleId: string, filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/byModule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(moduleId)));

            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [userId] Id of a User
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionGetByUser(userId: string, filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/byUser/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(userId)));

            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindById(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionFindById.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindOne(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPatchOrCreate(data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Crée une instance dans moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleId(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionPrototypeCreateModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Crée une instance dans moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleIdModuleId(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionPrototypeCreateModuleIdModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Supprime moduleId de ce modèle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleId(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionPrototypeDestroyModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Supprime moduleId de ce modèle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleIdModuleId(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionPrototypeDestroyModuleIdModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleId(id: string, refresh?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionPrototypeGetModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleIdModuleId(id: string, refresh?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionPrototypeGetModuleIdModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id session id
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypePatchAttributes(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionPrototypePatchAttributes.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Mettez à jour moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleId(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionPrototypeUpdateModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Mettez à jour moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleIdModuleId(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionPrototypeUpdateModuleIdModuleId.');
            }
            const localVarPath = `/sessions/{id}/moduleId/moduleId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPostSessionsidReplace(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionReplaceByIdPostSessionsidReplace.');
            }
            const localVarPath = `/sessions/{id}/replace`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPutSessionsid(id: string, data?: Session, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sessionReplaceByIdPutSessionsid.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePostSessionsReplaceOrCreate(data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/replaceOrCreate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePutSessions(data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpdateAll(where?: string, data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpsertWithWhere(where?: string, data?: Session, options: any = {}): FetchArgs {
            const localVarPath = `/sessions/upsertWithWhere`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewSession} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreate(data?: NewSession, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Register a user to a session and persist it into the data source.
         * @param {{ userId: string, sessionId: string }} [data] Registration data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionRegister(data?: { userId: string, sessionId: string }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionRegister(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },

        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamGetSessionsChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionCreateChangeStreamGetSessionsChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamPostSessionsChangeStream(paramsStream?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionCreateChangeStreamPostSessionsChangeStream(paramsStream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionDeleteById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionDeleteById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsGetSessionsidExists(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionExistsGetSessionsidExists(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsHeadSessionsid(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionExistsHeadSessionsid(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFind(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Session>> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionFind(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
        *
        * @summary Find all instances of the model matched by filter from the data source.
        * @param {string} [moduleId] Id of a module
        * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
        * @param {*} [options] Override http request option.
        * @throws {RequiredError}
        */
        sessionGetByModule(moduleId: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Session>> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionGetByModule(moduleId, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
        *
        * @summary Find all instances of the model matched by filter from the data source.
        * @param {string} [userId] Id of a User
        * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
        * @param {*} [options] Override http request option.
        * @throws {RequiredError}
        */
        sessionGetByUser(userId: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Session>> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionGetByUser(userId, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindById(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionFindById(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindOne(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionFindOne(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPatchOrCreate(data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPatchOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Crée une instance dans moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleId(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeCreateModuleId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Crée une instance dans moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleIdModuleId(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeCreateModuleIdModuleId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Supprime moduleId de ce modèle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleId(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeDestroyModuleId(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Supprime moduleId de ce modèle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleIdModuleId(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeDestroyModuleIdModuleId(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleId(id: string, refresh?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeGetModuleId(id, refresh, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleIdModuleId(id: string, refresh?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeGetModuleIdModuleId(id, refresh, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id session id
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypePatchAttributes(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypePatchAttributes(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Mettez à jour moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleId(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeUpdateModuleId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Mettez à jour moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleIdModuleId(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionPrototypeUpdateModuleIdModuleId(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPostSessionsidReplace(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionReplaceByIdPostSessionsidReplace(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPutSessionsid(id: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionReplaceByIdPutSessionsid(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePostSessionsReplaceOrCreate(data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionReplaceOrCreatePostSessionsReplaceOrCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePutSessions(data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionReplaceOrCreatePutSessions(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpdateAll(where?: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionUpdateAll(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpsertWithWhere(where?: string, data?: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).sessionUpsertWithWhere(where, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCount(where?: string, options?: any) {
            return SessionApiFp(configuration).sessionCount(where, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param {NewSession} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreate(data?: NewSession, options?: any) {
            return SessionApiFp(configuration).sessionCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamGetSessionsChangeStream(paramsStream?: string, options?: any) {
            return SessionApiFp(configuration).sessionCreateChangeStreamGetSessionsChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param {string} [paramsStream]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionCreateChangeStreamPostSessionsChangeStream(paramsStream?: string, options?: any) {
            return SessionApiFp(configuration).sessionCreateChangeStreamPostSessionsChangeStream(paramsStream, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionDeleteById(id: string, options?: any) {
            return SessionApiFp(configuration).sessionDeleteById(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsGetSessionsidExists(id: string, options?: any) {
            return SessionApiFp(configuration).sessionExistsGetSessionsidExists(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param {string} id Model id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionExistsHeadSessionsid(id: string, options?: any) {
            return SessionApiFp(configuration).sessionExistsHeadSessionsid(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFind(filter?: string, options?: any) {
            return SessionApiFp(configuration).sessionFind(filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindById(id: string, filter?: string, options?: any) {
            return SessionApiFp(configuration).sessionFindById(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param {string} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionFindOne(filter?: string, options?: any) {
            return SessionApiFp(configuration).sessionFindOne(filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPatchOrCreate(data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPatchOrCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Crée une instance dans moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleId(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeCreateModuleId(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Crée une instance dans moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeCreateModuleIdModuleId(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeCreateModuleIdModuleId(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Supprime moduleId de ce modèle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleId(id: string, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeDestroyModuleId(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Supprime moduleId de ce modèle.
         * @param {string} id session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeDestroyModuleIdModuleId(id: string, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeDestroyModuleIdModuleId(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleId(id: string, refresh?: boolean, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeGetModuleId(id, refresh, options)(fetch, basePath);
        },
        /**
         *
         * @summary Extrait la relation hasOne moduleId.
         * @param {string} id session id
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeGetModuleIdModuleId(id: string, refresh?: boolean, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeGetModuleIdModuleId(id, refresh, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param {string} id session id
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypePatchAttributes(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypePatchAttributes(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Mettez à jour moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleId(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeUpdateModuleId(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Mettez à jour moduleId de ce modèle.
         * @param {string} id session id
         * @param {Session} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPrototypeUpdateModuleIdModuleId(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionPrototypeUpdateModuleIdModuleId(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPostSessionsidReplace(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionReplaceByIdPostSessionsidReplace(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param {string} id Model id
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceByIdPutSessionsid(id: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionReplaceByIdPutSessionsid(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePostSessionsReplaceOrCreate(data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionReplaceOrCreatePostSessionsReplaceOrCreate(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param {Session} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionReplaceOrCreatePutSessions(data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionReplaceOrCreatePutSessions(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpdateAll(where?: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionUpdateAll(where, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param {string} [where] Criteria to match model instances
         * @param {Session} [data] An object of model property name/value pairs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionUpsertWithWhere(where?: string, data?: Session, options?: any) {
            return SessionApiFp(configuration).sessionUpsertWithWhere(where, data, options)(fetch, basePath);
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionCount(where?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionCount(where, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionCreate(data?: NewSession, options?: any) {
        return SessionApiFp(this.configuration).sessionCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Register a user to a session.
     * @param {} [data] Registration data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionRegister(data?: { userId: string, sessionId: string }, options?: any) {
        return SessionApiFp(this.configuration).sessionRegister(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a change stream.
     * @param {} [paramsStream]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionCreateChangeStreamGetSessionsChangeStream(paramsStream?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionCreateChangeStreamGetSessionsChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a change stream.
     * @param {} [paramsStream]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionCreateChangeStreamPostSessionsChangeStream(paramsStream?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionCreateChangeStreamPostSessionsChangeStream(paramsStream, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionDeleteById(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionDeleteById(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionExistsGetSessionsidExists(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionExistsGetSessionsidExists(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param {} id Model id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionExistsHeadSessionsid(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionExistsHeadSessionsid(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionFind(filter?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionFind(filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [moduleId] Id of a module
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionGetByModule(moduleId: string, filter?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionGetByModule(moduleId, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param {} [userId] Id of a user
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionGetByUser(userId: string, filter?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionGetByUser(userId, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param {} id Model id
     * @param {} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionFindById(id: string, filter?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionFindById(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param {} [filter] Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionFindOne(filter?: string, options?: any) {
        return SessionApiFp(this.configuration).sessionFindOne(filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPatchOrCreate(data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPatchOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Crée une instance dans moduleId de ce modèle.
     * @param {} id session id
     * @param {} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeCreateModuleId(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeCreateModuleId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Crée une instance dans moduleId de ce modèle.
     * @param {} id session id
     * @param {} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeCreateModuleIdModuleId(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeCreateModuleIdModuleId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Supprime moduleId de ce modèle.
     * @param {} id session id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeDestroyModuleId(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeDestroyModuleId(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Supprime moduleId de ce modèle.
     * @param {} id session id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeDestroyModuleIdModuleId(id: string, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeDestroyModuleIdModuleId(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Extrait la relation hasOne moduleId.
     * @param {} id session id
     * @param {} [refresh]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeGetModuleId(id: string, refresh?: boolean, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeGetModuleId(id, refresh, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Extrait la relation hasOne moduleId.
     * @param {} id session id
     * @param {} [refresh]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeGetModuleIdModuleId(id: string, refresh?: boolean, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeGetModuleIdModuleId(id, refresh, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param {} id session id
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypePatchAttributes(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypePatchAttributes(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Mettez à jour moduleId de ce modèle.
     * @param {} id session id
     * @param {} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeUpdateModuleId(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeUpdateModuleId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Mettez à jour moduleId de ce modèle.
     * @param {} id session id
     * @param {} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionPrototypeUpdateModuleIdModuleId(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionPrototypeUpdateModuleIdModuleId(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionReplaceByIdPostSessionsidReplace(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionReplaceByIdPostSessionsidReplace(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param {} id Model id
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionReplaceByIdPutSessionsid(id: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionReplaceByIdPutSessionsid(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionReplaceOrCreatePostSessionsReplaceOrCreate(data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionReplaceOrCreatePostSessionsReplaceOrCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param {} [data] Model instance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionReplaceOrCreatePutSessions(data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionReplaceOrCreatePutSessions(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionUpdateAll(where?: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionUpdateAll(where, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param {} [where] Criteria to match model instances
     * @param {} [data] An object of model property name/value pairs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionUpsertWithWhere(where?: string, data?: Session, options?: any) {
        return SessionApiFp(this.configuration).sessionUpsertWithWhere(where, data, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [where]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCountGet(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [filter]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling usersIdDelete.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling usersIdGet.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPatch(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling usersIdPatch.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [where]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * @param {NewUser} [data] Model instance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(data?: NewUser, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSigninPost(data?: UserCredentials, options: any = {}): FetchArgs {
            const localVarPath = `/users/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            const needsSerialization = (<any>"UserCredentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAuthSigninPost(data?: AuthCredentials, options: any = {}): FetchArgs {
            const localVarPath = `/users/auth/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            const needsSerialization = (<any>"AuthCredentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [where]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCountGet(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersCountGet(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} [filter]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersGet(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPatch(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdPatch(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} [where]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersPatch(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSigninPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersSigninPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} [where]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCountGet(where?: string, options?: any) {
            return UserApiFp(configuration).usersCountGet(where, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} [filter]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(filter?: string, options?: any) {
            return UserApiFp(configuration).usersGet(filter, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: string, options?: any) {
            return UserApiFp(configuration).usersIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: any) {
            return UserApiFp(configuration).usersIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPatch(id: string, options?: any) {
            return UserApiFp(configuration).usersIdPatch(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} [where]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch(where?: string, options?: any) {
            return UserApiFp(configuration).usersPatch(where, options)(fetch, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(options?: any) {
            return UserApiFp(configuration).usersPost(options)(fetch, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSigninPost(options?: any) {
            return UserApiFp(configuration).usersSigninPost(options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     *
     * @param {} [where]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersCountGet(where?: string, options?: any) {
        return UserApiFp(this.configuration).usersCountGet(where, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersGet(filter?: string, options?: any) {
        return UserApiFp(this.configuration).usersGet(filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdDelete(id: string, options?: any) {
        return UserApiFp(this.configuration).usersIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdGet(id: string, options?: any) {
        return UserApiFp(this.configuration).usersIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdPatch(id: string, options?: any) {
        return UserApiFp(this.configuration).usersIdPatch(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} [where]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersPatch(where?: string, options?: any) {
        return UserApiFp(this.configuration).usersPatch(where, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersPost(options?: any) {
        return UserApiFp(this.configuration).usersPost(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersSigninPost(options?: any) {
        return UserApiFp(this.configuration).usersSigninPost(options)(this.fetch, this.basePath);
    }
}
